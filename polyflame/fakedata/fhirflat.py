"""
Fake data generator for polyflame.fhirflat use

Resources are not guaranteed to be complete with respect to columns
generated by fhirflat output but MUST contain necessary columns for
testing of data transformations and plots.
"""

import functools
import hashlib
import operator
import random
import uuid
from pathlib import Path
from typing import Callable, Literal, TypedDict

import pandas as pd

from ..util import get_checksum

N = 50
WeightedCodes = dict[str, dict[str, float | int]]


class FlatMetadata(TypedDict):
    N: int
    generator: str
    checksum: str
    checksum_file: str


def checksum_text(checksums: dict[str, str]) -> str:
    return "\n".join(f"{checksums[k]}  {k}" for k in sorted(checksums)) + "\n"


def generate_metadata(folder_name: str | Path) -> tuple[FlatMetadata, dict[str, str]]:
    "Generate metadata for a FHIRFlat folder"

    checksums = {f.name: get_checksum(f) for f in Path(folder_name).glob("*.parquet")}
    m = hashlib.sha256()
    m.update(checksum_text(checksums).encode("utf-8"))

    # write checksums file
    return {
        "N": N,
        "generator": "polyflame.fakedata",
        "checksum": m.hexdigest(),
        "checksum_file": "sha256sums.txt",
    }, checksums


def generate_ids(N: int) -> list[str]:
    return [str(uuid.uuid4()) for _ in range(N)]


W: WeightedCodes = {
    "outcome": {
        "https://snomed.info/sct|371827001": 40,  # alive
        "https://snomed.info/sct|32485007": 1,  # still hospitalised
        "https://snomed.info/sct|306685000": 1,  # transferred
        "https://snomed.info/sct|419099009": 5,  # death
        "https://snomed.info/sct|306237005": 1,  # palliative care
        "https://snomed.info/sct|225928004": 2,  # discharged
    },
    "birthSex": {"http://snomed.info/sct|248153007": 1, "http://snomed.info/sct|248152002": 1},
    "condition": {
        "https://snomed.info/sct|38341003": 20,  # hypertension
        "https://snomed.info/sct|709044004": 10,  # chronic kidney disease
        "https://snomed.info/sct|73211009": 60,  # diabetes
        "https://snomed.info/sct|44054006": 40,  # diabetes type 2
        "https://snomed.info/sct|46635009": 10,  # diabetes type 1
        "https://snomed.info/sct|274640006": 500,  # fever
        "https://snomed.info/sct|25064002": 40,  # headache
        "https://snomed.info/sct|68962001": 10,  # muscle pain
        "https://snomed.info/sct|422400008": 5,  # vomiting
    },
    "presenceAbsence": {
        "https://snomed.info/sct|373066003": 6,  # true
        "https://snomed.info/sct|373067005": 4,  # false
    },
}

IDs = generate_ids(N)
Patient = TypedDict(
    "Patient",
    {
        "extension.age.code": list[
            Literal["https://unitsofmeasure.org|a", "https://unitsofmeasure.org|mo"]
        ],
        "extension.age.unit": Literal["Years", "Months"],
        "extension.age.value": int,
        "extension.birthSex.code": list[str],
        "id": str,
    },
)
Condition = TypedDict(
    "Condition",
    {
        "subject": str,
        "encounter": str,
        "code.code": list[str],
        "extension.presenceAbsence.code": list[str],
    },
)

Encounter = TypedDict(
    "Encounter",
    {
        "subject": str,
        "admission.dischargeDisposition.code": list[str],
    },
)

Resource = Patient | Encounter | Condition


def random_code(section: str) -> str:
    assert section in W, f"Section {section} not found in weighted codes"
    codes, weights = zip(*W[section].items(), strict=False)
    return random.choices(codes, weights)[0]


def generate_patient(id: str) -> Patient:
    return {
        "extension.age.code": ["https://unitsofmeasure.org|a"],
        "extension.age.unit": "Years",
        "extension.age.value": random.choice(range(2, 100)),  # no infants
        "extension.birthSex.code": [random_code("birthSex")],
        "id": id,
    }


def generate_encounter(id: str) -> Encounter:
    return {
        "subject": f"Patient/{id}",
        "admission.dischargeDisposition.code": [random_code("outcome")],
    }


def generate_condition(id: str) -> list[Condition]:
    n_conditions = random.choices(range(5), weights=[48, 8, 4, 2, 1])[0] + 1
    population_conditions, counts = zip(*W["condition"].items(), strict=False)
    conditions = random.sample(population_conditions, n_conditions, counts=counts)
    presenceAbsences = [random_code("presenceAbsence") for _ in range(len(conditions))]
    return [
        {
            "subject": f"Patient/{id}",
            "encounter": f"Encounter/{id}",
            "code.code": [condition],
            "extension.presenceAbsence.code": [presenceAbsence],
        }
        for condition, presenceAbsence in zip(conditions, presenceAbsences, strict=False)
    ]


def save_part(
    folder: Path, resource: str, func: Callable[[str], Resource | list[Resource]]
) -> Path:
    resources = list(map(func, IDs))
    if isinstance(resources[0], list):
        resources = functools.reduce(operator.iadd, resources, [])  # type: ignore
    file = folder / f"{resource}.parquet"
    pd.DataFrame(resources).to_parquet(file, index=False)
    return file


def write_fhirflat(folder: str | Path) -> FlatMetadata:
    "Write fake data to folder"
    folder = Path(folder)
    if not folder.exists():
        folder.mkdir()
    print(
        [
            save_part(folder, "patient", generate_patient),
            save_part(folder, "encounter", generate_encounter),
            save_part(folder, "condition", generate_condition),  # type: ignore
        ]
    )
    metadata, checksums = generate_metadata(folder)

    # write checksums
    (folder / "sha256sums.txt").write_text(checksum_text(checksums))
    # write metadata
    metadata_text = f"""[metadata]
N = {metadata['N']}
generator = "{metadata['generator']}"
checksum = "{metadata['checksum']}"
checksum_file = "{metadata['checksum_file']}"
"""
    (folder / "fhirflat.toml").write_text(metadata_text)
    return metadata
